# Editor base class for nixpkgs plugin update scripts

import argparse
import functools
import logging
import os
import re
from datetime import datetime
from multiprocessing.dummy import Pool
from pathlib import Path
from typing import TYPE_CHECKING

import git

if TYPE_CHECKING:
    from .repos import Repo

from .cache import Cache
from .fetching import Redirects, check_results, prefetch, prefetch_plugin
from .operations import commit, rewrite_input
from .plugin import Plugin, PluginDesc, load_plugins_from_csv
from .utils import FetchConfig, run_nix_expr

log = logging.getLogger()


class Editor:
    """The configuration of the update script."""

    def __init__(
        self,
        name: str,
        root: Path,
        get_plugins: str,
        default_in: Path | None = None,
        default_out: Path | None = None,
        deprecated: Path | None = None,
        cache_file: str | None = None,
    ):
        log.debug("get_plugins: %s", get_plugins)
        self.name = name
        self.root = root
        self.get_plugins = get_plugins
        self.default_in = default_in or root.joinpath(f"{name}-plugin-names")
        self.default_out = default_out or root.joinpath("generated.nix")
        self.deprecated = deprecated or root.joinpath("deprecated.json")
        self.cache_file = cache_file or f"{name}-plugin-cache.json"
        self.nixpkgs_repo: git.Repo | None = None
        self.nixpkgs: str = (
            ""  # Path to nixpkgs checkout, set by subclasses or externally
        )

    def add(self, args):
        """CSV spec"""
        log.debug("called the 'add' command")
        fetch_config = FetchConfig(args.proc, args.github_token)
        editor = self
        for plugin_line in args.add_plugins:
            log.debug("using plugin_line %s", plugin_line)
            pdesc = PluginDesc.load_from_string(fetch_config, plugin_line)
            log.debug("loaded as pdesc %s", pdesc)
            append = [pdesc]
            editor.rewrite_input(
                fetch_config, args.input_file, editor.deprecated, append=append
            )
            plugin, _ = prefetch_plugin(pdesc)

            if (  # lua updater doesn't support updating individual plugin
                self.name != "lua"
            ):
                # update generated.nix
                update = self.get_update(
                    args.input_file,
                    args.outfile,
                    fetch_config,
                    [plugin.normalized_name],
                )
                update()

            autocommit = not args.no_commit
            if autocommit:
                assert editor.nixpkgs_repo is not None
                drv_name = editor.get_drv_name(plugin.normalized_name)
                commit(
                    editor.nixpkgs_repo,
                    f"{drv_name}: init at {plugin.version}",
                    [args.outfile, args.input_file],
                )

    # Expects arguments generated by 'update' subparser
    def update(self, _args):
        """CSV spec"""
        print("the update member function should be overridden in subclasses")

    def get_current_plugins(
        self, config: FetchConfig, nixpkgs: str
    ) -> list[tuple[PluginDesc, Plugin]]:
        """To fill the cache"""
        data = run_nix_expr(self.get_plugins, nixpkgs)
        plugins = []
        for name, attr in data.items():
            checksum = attr["checksum"]

            # Parse version in format: <tag>-unstable-YYYY-MM-DD
            version_str = attr["version"]

            # Extract date (always at the end)
            date_match = re.search(r"(\d{4}-\d{2}-\d{2})$", version_str)
            if date_match is None:
                raise ValueError(f"Cannot parse date from version: {version_str}")
            date = datetime.strptime(date_match.group(1), "%Y-%m-%d")

            # Extract tag (everything before "-unstable-")
            tag_match = re.search(r"^(.+?)-unstable-", version_str)
            last_tag = None
            if tag_match:
                tag_part = tag_match.group(1)
                # If tag_part is "0", it means no tag exists
                if tag_part != "0":
                    last_tag = tag_part

            pdesc = PluginDesc.load_from_string(config, f"{attr['homePage']} as {name}")
            p = Plugin(
                attr["pname"],
                checksum["rev"],
                checksum["submodules"],
                checksum["sha256"],
                date,
                last_tag=last_tag,
            )

            plugins.append((pdesc, p))
        return plugins

    def load_plugin_spec(self, config: FetchConfig, plugin_file) -> list[PluginDesc]:
        """CSV spec"""
        return load_plugins_from_csv(config, plugin_file)

    def generate_nix(self, _plugins, _outfile: str):
        """Returns nothing for now, writes directly to outfile"""
        raise NotImplementedError()

    def filter_plugins_to_update(
        self, plugin: PluginDesc, to_update: list[str]
    ) -> bool:
        """Function for filtering out plugins, that user doesn't want to update.

        It is mainly used for updating only specific plugins, not all of them.
        By default it filters out plugins not present in `to_update`,
        assuming `to_update` is a list of plugin names (the same as in the
        result expression).

        This function is never called if `to_update` is empty.
        Feel free to override this function in derived classes.

        Note:
            Known bug: you have to use a deprecated name, instead of new one.
            This is because we resolve deprecations later and can't get new
            plugin URL before we request info about it.

            Although, we could parse deprecated.json, but it's a whole bunch
            of spaghetti code, which I don't want to write.

        Arguments:
            plugin: Plugin on which you decide whether to ignore or not.
            to_update:
                List of strings passed to via the `--update` command line parameter.
                By default, we assume it is a list of URIs identical to what
                is in the input file.

        Returns:
            True if we should update plugin and False if not.
        """
        return plugin.name.replace(".", "-") in to_update

    def get_update(
        self,
        input_file: str,
        output_file: str,
        config: FetchConfig,
        to_update: list[str] | None,
    ):
        if to_update is None:
            to_update = []

        current_plugins = self.get_current_plugins(config, self.nixpkgs)
        current_plugin_specs = self.load_plugin_spec(config, input_file)

        cache: Cache = Cache(
            [plugin for _description, plugin in current_plugins], self.cache_file
        )
        _prefetch = functools.partial(prefetch, cache=cache)

        to_update_for_filter = [x.replace(".", "-") for x in to_update]
        plugins_to_update = (
            current_plugin_specs
            if len(to_update) == 0
            else [
                description
                for description in current_plugin_specs
                if self.filter_plugins_to_update(description, to_update_for_filter)
            ]
        )

        def update() -> Redirects:
            if len(plugins_to_update) == 0:
                log.error(
                    "\n\n\n\nIt seems like you provided some arguments to `--update`:\n%s\n"
                    "But after filtering, the result list of plugins is empty\n\n"
                    "Are you sure you provided the same URIs as in your input file?\n"
                    "(%s)\n\n",
                    ", ".join(to_update),
                    input_file,
                )
                return {}

            try:
                pool = Pool(processes=config.proc)
                results = pool.map(_prefetch, plugins_to_update)
            finally:
                cache.store()

            print(f"{len(results)} of {len(current_plugins)} were checked")
            # Do only partial update of out file
            if len(results) != len(current_plugins):
                results = self.merge_results(current_plugins, results)
            plugins, redirects = check_results(results)

            plugins = sorted(plugins, key=lambda v: v[1].normalized_name)
            self.generate_nix(plugins, output_file)

            return redirects

        return update

    def merge_results(
        self,
        current: list[tuple[PluginDesc, Plugin]],
        fetched: list[tuple[PluginDesc, Exception | Plugin, "Repo | None"]],
    ) -> list[tuple[PluginDesc, Exception | Plugin, "Repo | None"]]:
        # transforming this to dict, so lookup is O(1) instead of O(n) (n is len(current))
        result: dict[str, tuple[PluginDesc, Exception | Plugin, "Repo | None"]] = {
            # also adding redirect (third item in the result tuple)
            pl.normalized_name: (pdesc, pl, None)
            for pdesc, pl in current
        }

        for plugin_desc, plugin, redirect in fetched:
            # Check if plugin is a Plugin object and has normalized_name attribute
            if isinstance(plugin, Plugin) and hasattr(plugin, "normalized_name"):
                result[plugin.normalized_name] = (plugin_desc, plugin, redirect)
            elif isinstance(plugin, Exception):
                # For exceptions, we can't determine the normalized_name
                # Just log the error and continue
                log.error("Error fetching plugin %s: %r", plugin_desc.name, plugin)
            else:
                # For unexpected types, log the issue
                log.error(
                    "Unexpected plugin type for %s: %s", plugin_desc.name, type(plugin)
                )

        return list(result.values())

    @property
    def attr_path(self):
        return self.name + "Plugins"

    def get_drv_name(self, name: str):
        return self.attr_path + "." + name

    def rewrite_input(self, *args, **kwargs):
        return rewrite_input(*args, **kwargs)

    def create_parser(self):
        from .utils import LOG_LEVELS

        common = argparse.ArgumentParser(
            add_help=False,
            description=(
                f"""
                Updates nix derivations for {self.name} plugins.\n
                By default from {self.default_in} to {self.default_out}"""
            ),
        )
        common.add_argument(
            "--nixpkgs",
            type=str,
            default=os.getcwd(),
            help="Adjust log level",
        )
        common.add_argument(
            "--input-names",
            "-i",
            dest="input_file",
            type=Path,
            default=self.default_in,
            help="A list of plugins in the form owner/repo",
        )
        common.add_argument(
            "--out",
            "-o",
            dest="outfile",
            default=self.default_out,
            type=Path,
            help="Filename to save generated nix code",
        )
        common.add_argument(
            "--proc",
            "-p",
            dest="proc",
            type=int,
            default=30,
            help="Number of concurrent processes to spawn. Setting --github-token allows higher values.",
        )
        common.add_argument(
            "--github-token",
            "-t",
            type=str,
            default=os.getenv("GITHUB_TOKEN"),
            help="""Allows to set --proc to higher values.
            Uses GITHUB_TOKEN environment variables as the default value.""",
        )
        common.add_argument(
            "--no-commit",
            "-n",
            action="store_true",
            default=False,
            help="Whether to autocommit changes",
        )
        common.add_argument(
            "--debug",
            "-d",
            choices=LOG_LEVELS.keys(),
            default=logging.getLevelName(logging.WARN),
            help="Adjust log level",
        )

        main = argparse.ArgumentParser(
            parents=[common],
            description=(
                f"""
                Updates nix derivations for {self.name} plugins.\n
                By default from {self.default_in} to {self.default_out}"""
            ),
        )

        subparsers = main.add_subparsers(dest="command", required=False)
        padd = subparsers.add_parser(
            "add",
            parents=[],
            description="Add new plugin",
            add_help=False,
        )
        padd.set_defaults(func=self.add)
        padd.add_argument(
            "add_plugins",
            default=None,
            nargs="+",
            help=f"Plugin to add to {self.attr_path} from Github in the form owner/repo",
        )

        pupdate = subparsers.add_parser(
            "update",
            description="Update all or a subset of existing plugins",
            add_help=False,
        )
        pupdate.add_argument(
            "update_only",
            default=None,
            nargs="*",
            help="Plugin URLs to update (must be the same as in the input file)",
        )
        pupdate.set_defaults(func=self.update)
        return main

    def run(self):
        """
        Convenience function
        """
        from .utils import LOG_LEVELS

        parser = self.create_parser()
        args = parser.parse_args()
        command = args.command or "update"
        logging.basicConfig()
        log.setLevel(LOG_LEVELS[args.debug])
        log.info("Chose to run command: %s", command)
        self.nixpkgs = args.nixpkgs

        self.nixpkgs_repo = git.Repo(args.nixpkgs, search_parent_directories=True)

        getattr(self, command)(args)
